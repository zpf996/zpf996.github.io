---
layout:     post
title:      面试题 主要元素  摩尔投票算法
subtitle:   DCT
date:       2020-9-1
author:     leon7777
header-img: img/user.jpg
catalog: 	 true
tags:
    - c
    - 数组
    - 算法
---
# 摩尔投票算法
## 题目
```
数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。
```
示例  
```
输入：[1,2,5,9,5,9,5,5,5]
输出：5
```
```
输入：[3,2]
输出：-1
```
## 解题思路
### 暴力方法
暴力方法，将所有的元素次数统计一遍，将最大的元素找出，代价巨大。  
### 摩尔投票算法
摩尔投票算法是一种使用线性时间和常数空间查找大部分元素序列的算法。  
要求：存在超过(n/2)的元素  
有一个序列元素(n)和一个计数元素(cont)  
开始计数元素cont为0，第一个元素为查找元素  
```
摩尔投票法算法的本质思想就是：抵消，抵消，抵消，到不能再抵消为止。
```
可以理解为一个栈，压入第一个元素，如果下一个元素与当前元素相同，则入栈，反之则出栈，最后留下的则为主要元素  
### 示例
```
[1,2,1,3,1,2,1,3,1] 当前数组，注意要有一个超过或者等于当前数组一半元素数的元素

[1,2,1,3,1,2,1,3,1] n=1,cont=0 //初始化，n为数组第一个元素
[*1,2,1,3,1,2,1,3,1] n=1,cont=1
[1,*2,1,3,1,2,1,3,1] n=1,cont=0
[1,2,*1,3,1,2,1,3,1] n=1,cont=1
[1,2,1,*3,1,2,1,3,1] n=1,cont=0
[1,2,1,3,*1,2,1,3,1] n=1,cont=1
[1,2,1,3,1,*2,1,3,1] n=1,cont=0
[1,2,1,3,1,2,*1,3,1] n=1,cont=1
[1,2,1,3,1,2,1,*3,1] n=1,cont=0
[1,2,1,3,1,2,1,3,*1] n=1,cont=1

栈的抵消形式
[1,1,1,2,3,1]
->1 
->1 1
->1 1 1   
->1 1     //2与1抵消
->1       //3与1抵消
->1 1
```
通过这个步骤，可以看出采用两个辅助空间便可实现栈的功能  
## 代码
c实现
```c
int majorityElement(int* nums, int numsSize){
    int n=nums[0],cont=0;
    
    if(nums==0)
    {
        return -1;
    }

    for(int i=0;i<numsSize;i++)
    {
        if(nums[i]==n)
        {
            cont++;
        }
        else
        {
            cont--;
        }
        if(cont==0)
        {
            n=nums[i+1];
        }
    }
    if(cont==0)
    {
        return -1;
    }
    return n;
}
```
java实现
```java
class Solution {
    public int majorityElement(int[] nums) {
        int i,n,cont=1;
        n=nums[0];
        for(i=1;i<nums.length;i++)
        {
            if(n==nums[i])
            {
                cont++;
            }
            else
            {
                cont--;
            }
            if(cont==0)
            {
                n=nums[i+1];
            }
        }
        if(cont==0)
        {
            return -1;
        }
        return n;
    }
   
}
```